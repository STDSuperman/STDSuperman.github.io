(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{406:function(s,n,e){"use strict";e.r(n);var a=e(27),t=Object(a.a)({},(function(){var s=this,n=s.$createElement,e=s._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[e("img",{attrs:{src:"https://my-blog-1257398419.cos.ap-chengdu.myqcloud.com/blog/6.jpg",alt:""}})]),s._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),e("blockquote",[e("p",[s._v("众所周知，随着 "),e("code",[s._v("Vue")]),s._v(" 技术的越来越热，大量的前端开发者开始探究这门神奇的框架，笔者也是从 "),e("code",[s._v("JQuery")]),s._v(" 时代一脚迈进了 "),e("code",[s._v("Vue")]),s._v(" 的世界。谈到"),e("code",[s._v("Vue")]),s._v("，在这呢，就不得不提一下笔者在研究一个"),e("code",[s._v("Vue")]),s._v("项目的时候碰到的问题，父组件修改标志位变量，而子组件的相应组件并没有显示，后来通过多方研究，发现了 "),e("code",[s._v("Vue.nextTick")]),s._v("这个原型方法可以达到我想要的这个效果，所以笔者今天也来谈谈这个神奇的方法。")])]),s._v(" "),e("h4",{attrs:{id:"vue-nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-nexttick"}},[s._v("#")]),s._v(" Vue.nextTick")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("参数")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("{Function} [callback]")])]),s._v(" "),e("li",[e("code",[s._v("{Object} [context]")])])])]),s._v(" "),e("li",[e("p",[s._v("用法")]),s._v(" "),e("p",[s._v("在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。")])])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// 修改数据\nvm.msg = 'Hello'\n// DOM 还没有更新\nVue.nextTick(function () {\n  // DOM 更新了\n})\n\n// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)\nVue.nextTick()\n  .then(function () {\n    // DOM 更新了\n  })\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("blockquote",[e("p",[s._v("这里其实涉及到 "),e("code",[s._v("js")]),s._v(" 的事件循环机制，有兴趣的话可以右转 "),e("a",{attrs:{href:"https://juejin.im/post/5b24b116e51d4558a65fdb70",target:"_blank",rel:"noopener noreferrer"}},[s._v("js事件循环"),e("OutboundLink")],1)])]),s._v(" "),e("p",[s._v("具体使用场景各位小伙伴应该也不用笔者多啰嗦了，今天笔者的重点还是研究一下这个东西源码是怎么实现的，毕竟作为当代前端一员至少不能只会用 "),e("code",[s._v("API")]),s._v(" 了，咱们还是去底层假装研究一下是吧。")]),s._v(" "),e("h2",{attrs:{id:"vue-nexttick源码解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-nexttick源码解析"}},[s._v("#")]),s._v(" Vue.nextTick源码解析")]),s._v(" "),e("h4",{attrs:{id:"js事件循环机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js事件循环机制"}},[s._v("#")]),s._v(" js事件循环机制")]),s._v(" "),e("blockquote",[e("p",[s._v("其实话说起来，我们就得来了解一下这个 "),e("code",[s._v("js")]),s._v(" 是单线程的这个特性上来了，它其实所有事件的处理都依赖于这一个事件循环机制，，主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度被调度，消息队列中存放的是一个个的任务"),e("code",[s._v("task")]),s._v("。 规范中规定 "),e("code",[s._v("task")]),s._v(" 分为两大类，分别是"),e("code",[s._v("macro task")]),s._v("(宏任务) 和"),e("code",[s._v("micro task")]),s._v("(微任务)，并且每个 "),e("code",[s._v("macro task")]),s._v(" 结束后，都要清空所有的"),e("code",[s._v("micro task")]),s._v("。")])]),s._v(" "),e("p",[s._v("回到正题，"),e("code",[s._v("Vue.nextTick")]),s._v(" 怎么实现当前页面更新完之后最早执行它所绑定的回调呢，这就用到了我们上面所说的这个任务队列，每次当前宏任务执行完毕之前，都会清空所有微任务，那么为了在界面更新完之后最短时间内执行回调，最佳选择不就是这个微任务了么，利用这个机制，我们总能在下次事件循环之前把我们要处理的事件处理掉。")]),s._v(" "),e("h4",{attrs:{id:"微任务-宏任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微任务-宏任务"}},[s._v("#")]),s._v(" 微任务 宏任务")]),s._v(" "),e("blockquote",[e("p",[s._v("常见的宏任务有 "),e("code",[s._v("setTimeout")]),s._v("、"),e("code",[s._v("MessageChannel")]),s._v("、"),e("code",[s._v("postMessage")]),s._v("、"),e("code",[s._v("setImmediate")])])]),s._v(" "),e("blockquote",[e("p",[s._v("微任务有 "),e("code",[s._v("MutationObserver")]),s._v(" 和 "),e("code",[s._v("Promise.then")]),s._v(" 以及 "),e("code",[s._v("node")]),s._v(" 的 "),e("code",[s._v("process.nextTick")])])]),s._v(" "),e("p",[s._v("当然，为了程序的优化和性能提升，我们的最佳选择当然是 "),e("code",[s._v("Promise")]),s._v(" 啦，可是呢，"),e("code",[s._v("Promise")]),s._v(" 属于"),e("code",[s._v("es6")]),s._v("中提出的，部分浏览器可能出现不兼容的情况 "),e("code",[s._v("(PS: IE:你看我干嘛?)")]),s._v("，所以官方就给了一个优雅降级策略，如果当前浏览器支持 "),e("code",[s._v("Promise")]),s._v(" 则使用"),e("code",[s._v("Promise")]),s._v("，其次就是"),e("code",[s._v("MutationObserver")]),s._v("，如果以上两个都不支持，就只能搬出我们的"),e("code",[s._v("setTimeout")]),s._v("了。话不多说，下面开始搬代码。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(" //存储需要触发的回调函数\n  var callbacks=[];\n  /**是否正在等待的标志（false:允许触发在下次事件循环触发callbacks中的回调,\n  *  true: 已经触发过,需要等到下次事件循环）\n  */\n  var pending=false;\n  //设置在下次事件循环触发callbacks的触发函数\n  var timerFunc;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("上面的这个"),e("code",[s._v("timerFunc")]),s._v(" 将用于达到触发条件后触发所有回调函数")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  //处理callbacks的函数\n  function nextTickHandler() {\n      // 可以触发timeFunc\n      pending=false;\n      //复制callback\n      var copies=callbacks.slice(0);\n      //清除callback\n      callbacks.length=0;\n      for(var i=0;i<copies.length;i++){\n          //触发callback的回调函数\n          copies[i]();\n      }\n  }\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br")])]),e("p",[s._v("这部分代码就是实现触发所有绑定的回调函数的主要逻辑部分，下面我们来看看官方的的优雅降级策略怎么实现的")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("  //如果支持promise，使用promise实现\n  if(typeof Promise !=='undefined' && isNative(promise)){\n      var p=Promise.resolve();\n      var logError=function (err) {\n          console.error(err);\n      };\n      timerFunc=function () {\n          p.then(nextTickHandler).catch(logError);\n          //iOS的webview下，需要强制刷新队列，执行上面的回调函数\n          if(isIOS) {setTimeout(noop);}\n      };\n  //    如果Promise不支持，但支持MutationObserver\n  //    H5新特性，异步,当dom变动是触发,注意是所有的dom都改变结束后触发\n  } else if (typeof MutationObserver !=='undefined' && (\n      isNative(MutationObserver) ||\n      MutationObserver.toString()==='[object MutationObserverConstructor]')){\n          var counter = 1;\n          var observer=new MutationObserver(nextTickHandler);\n          var textNode=document.createTextNode(String(counter));\n          observer.observe(textNode,{\n              characterData:true\n          });\n          timerFunc=function () {\n              counter=(counter+1)%2;\n              textNode.data=String(counter);\n          };\n  } else {\n      //上面两种都不支持，用setTimeout\n      timerFunc=function () {\n          setTimeout(nextTickHandler,0);\n      };\n  }\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br")])]),e("p",[s._v("看完这段代码，大家可能对官方的这个降级策略有了一种恍然大悟的感觉，不过可能大家也会有疑问，这个MutationObserver的实现方式怎么这么诡异，那让我们来看看它的用法吧。")]),s._v(" "),e("h4",{attrs:{id:"mutationobserver-概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutationobserver-概述"}},[s._v("#")]),s._v(" MutationObserver 概述")]),s._v(" "),e("ul",[e("li",[s._v("监视 DOM 变动的接口当监视的 DOM 发生变动时 MutationObserver 将收到通知并触发事先设定好的回调函数。")]),s._v(" "),e("li",[s._v("类似于事件，但是异步触发。添加监视时，MutationObserver 上的 observer 函数与 addEventListener 有相似之处，但不同于后者的同步触发，MutationObserver是异步触发，此举是为了避免 DOM 频繁变动导致回调函数被频繁调用，造成浏览器卡顿。")])]),s._v(" "),e("h4",{attrs:{id:"mutationobserver-构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutationobserver-构造函数"}},[s._v("#")]),s._v(" MutationObserver 构造函数")]),s._v(" "),e("p",[s._v("该构造函数用于实例化一个新的 MutaionObserver ，同时指定触发 DOM 变动时的回调函数：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("var observer = new MutationObserver(callback);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("callback，即回调函数接收两个参数，第一个参数是一个包含了所有 MutationRecord 对象的数组，第二个参数则是这个MutationObserver 实例本身。具体详细介绍可以参考\n"),e("a",{attrs:{href:"https://user-gold-cdn.xitu.io/2019/6/30/16ba662cafa7e124",target:"_blank",rel:"noopener noreferrer"}},[s._v("深入了解MutationObserver"),e("OutboundLink")],1),s._v("。")]),s._v(" "),e("p",[s._v("咳咳咳，回到正题")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(" //nextTick接收的函数，参数1：回调函数 参数2：回调函数的执行上下文\n  return function queueNextTick(cb,ctx) {\n      //用于接收触发Promise.then中回调的函数\n      //向回调函数中pushcallback\n      var _resolve;\n      callbacks.push(function () {\n          //如果有回调函数，执行回调函数\n          if(cb) {cb.call(ctx);}\n          //触发Promise的then回调\n          if(_resolve) {_resolve(ctx);}\n      });\n      //是否执行刷新callback队列\n      if(!pending){\n          pending=true;\n          timerFunc();\n      }\n      //如果没有传递回调函数，并且当前浏览器支持promise，使用promise实现\n      if(!cb && typeof  Promise !=='undefined'){\n          return new Promise(function (resolve) {\n              _resolve=resolve;\n          })\n      }\n  }\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br")])]),e("p",[s._v("以上其实就是你调用这个方法实际调用的函数啦，利用闭包原理保存了前面提到的各个函数的引用，首先他会把你传入的回调函数包装一下保存到"),e("code",[s._v("callback")]),s._v("数组中。")]),s._v(" "),e("p",[s._v("如果当前队列还未执行过回调，那么开始执行回调，并把"),e("code",[s._v("pending")]),s._v("标志位置为"),e("code",[s._v("true")]),s._v("，表示当前任务队列已经执行过回调。")]),s._v(" "),e("p",[s._v("然后最后加一层判断，如果当前浏览器具有"),e("code",[s._v("Promise")]),s._v("环境且未传递回调函数则采用"),e("code",[s._v("Promise")]),s._v("执行。")]),s._v(" "),e("blockquote",[e("p",[s._v("最后附上完整代码")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("export const nextTick=(function () {\n  //存储需要触发的回调函数\n  var callbacks=[];\n  //是否正在等待的标志（false:允许触发在下次事件循环触发callbacks中的回调,\n  // true: 已经触发过,需要等到下次事件循环）\n  var pending=false;\n  //设置在下次事件循环触发callbacks的触发函数\n  var timerFunc;\n\n  //处理callbacks的函数\n  function nextTickHandler() {\n      // 可以触发timeFunc\n      pending=false;\n      //复制callback\n      var copies=callbacks.slice(0);\n      //清除callback\n      callbacks.length=0;\n      for(var i=0;i<copies.length;i++){\n          //触发callback的回调函数\n          copies[i]();\n      }\n  }\n  //如果支持promise，使用promise实现\n  if(typeof Promise !=='undefined' && isNative(promise)){\n      var p=Promise.resolve();\n      var logError=function (err) {\n          console.error(err);\n      };\n      timerFunc=function () {\n          p.then(nextTickHandler).catch(logError);\n          //iOS的webview下，需要强制刷新队列，执行上面的回调函数\n          if(isIOS) {setTimeout(noop);}\n      };\n  //    如果Promise不支持，但支持MutationObserver\n  //    H5新特性，异步,当dom变动是触发,注意是所有的dom都改变结束后触发\n  } else if (typeof MutationObserver !=='undefined' && (\n      isNative(MutationObserver) ||\n      MutationObserver.toString()==='[object MutationObserverConstructor]')){\n          var counter = 1;\n          var observer=new MutationObserver(nextTickHandler);\n          var textNode=document.createTextNode(String(counter));\n          observer.observe(textNode,{\n              characterData:true\n          });\n          timerFunc=function () {\n              counter=(counter+1)%2;\n              textNode.data=String(counter);\n          };\n  } else {\n      //上面两种都不支持，用setTimeout\n      timerFunc=function () {\n          setTimeout(nextTickHandler,0);\n      };\n  }\n  //nextTick接收的函数，参数1：回调函数 参数2：回调函数的执行上下文\n  return function queueNextTick(cb,ctx) {\n      //用于接收触发Promise.then中回调的函数\n      //向回调函数中pushcallback\n      var _resolve;\n      callbacks.push(function () {\n          //如果有回调函数，执行回调函数\n          if(cb) {cb.call(ctx);}\n          //触发Promise的then回调\n          if(_resolve) {_resolve(ctx);}\n      });\n      //是否执行刷新callback队列\n      if(!pending){\n          pending=true;\n          timerFunc();\n      }\n      //如果没有传递回调函数，并且当前浏览器支持promise，使用promise实现\n      if(!cb && typeof  Promise !=='undefined'){\n          return new Promise(function (resolve) {\n              _resolve=resolve;\n          })\n      }\n  }\n})()\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br"),e("span",{staticClass:"line-number"},[s._v("37")]),e("br"),e("span",{staticClass:"line-number"},[s._v("38")]),e("br"),e("span",{staticClass:"line-number"},[s._v("39")]),e("br"),e("span",{staticClass:"line-number"},[s._v("40")]),e("br"),e("span",{staticClass:"line-number"},[s._v("41")]),e("br"),e("span",{staticClass:"line-number"},[s._v("42")]),e("br"),e("span",{staticClass:"line-number"},[s._v("43")]),e("br"),e("span",{staticClass:"line-number"},[s._v("44")]),e("br"),e("span",{staticClass:"line-number"},[s._v("45")]),e("br"),e("span",{staticClass:"line-number"},[s._v("46")]),e("br"),e("span",{staticClass:"line-number"},[s._v("47")]),e("br"),e("span",{staticClass:"line-number"},[s._v("48")]),e("br"),e("span",{staticClass:"line-number"},[s._v("49")]),e("br"),e("span",{staticClass:"line-number"},[s._v("50")]),e("br"),e("span",{staticClass:"line-number"},[s._v("51")]),e("br"),e("span",{staticClass:"line-number"},[s._v("52")]),e("br"),e("span",{staticClass:"line-number"},[s._v("53")]),e("br"),e("span",{staticClass:"line-number"},[s._v("54")]),e("br"),e("span",{staticClass:"line-number"},[s._v("55")]),e("br"),e("span",{staticClass:"line-number"},[s._v("56")]),e("br"),e("span",{staticClass:"line-number"},[s._v("57")]),e("br"),e("span",{staticClass:"line-number"},[s._v("58")]),e("br"),e("span",{staticClass:"line-number"},[s._v("59")]),e("br"),e("span",{staticClass:"line-number"},[s._v("60")]),e("br"),e("span",{staticClass:"line-number"},[s._v("61")]),e("br"),e("span",{staticClass:"line-number"},[s._v("62")]),e("br"),e("span",{staticClass:"line-number"},[s._v("63")]),e("br"),e("span",{staticClass:"line-number"},[s._v("64")]),e("br"),e("span",{staticClass:"line-number"},[s._v("65")]),e("br"),e("span",{staticClass:"line-number"},[s._v("66")]),e("br"),e("span",{staticClass:"line-number"},[s._v("67")]),e("br"),e("span",{staticClass:"line-number"},[s._v("68")]),e("br"),e("span",{staticClass:"line-number"},[s._v("69")]),e("br"),e("span",{staticClass:"line-number"},[s._v("70")]),e("br"),e("span",{staticClass:"line-number"},[s._v("71")]),e("br"),e("span",{staticClass:"line-number"},[s._v("72")]),e("br"),e("span",{staticClass:"line-number"},[s._v("73")]),e("br"),e("span",{staticClass:"line-number"},[s._v("74")]),e("br"),e("span",{staticClass:"line-number"},[s._v("75")]),e("br"),e("span",{staticClass:"line-number"},[s._v("76")]),e("br"),e("span",{staticClass:"line-number"},[s._v("77")]),e("br"),e("span",{staticClass:"line-number"},[s._v("78")]),e("br")])]),e("p",[e("img",{attrs:{src:"https://my-blog-1257398419.cos.ap-chengdu.myqcloud.com/blog/7.jpg",alt:""}})]),s._v(" "),e("blockquote",[e("p",[s._v("好啦本文暂时介绍到这里，如果发现笔者写的不对的地方，欢迎给笔者留言。")])])])}),[],!1,null,null,null);n.default=t.exports}}]);